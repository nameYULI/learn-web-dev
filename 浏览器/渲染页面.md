<blockquote>大部分情况下 浏览器是单线程执行的 通过了解浏览器单线程的本质与最小化主线程的责任可以优化 Web 性能</blockquote>

## 导航

导航是加载 Web 页面的第一步 它发生在以下情形 用户通过在地址栏输入一个 URL、点击一个链接、提交表单或者是其他的行为

Web 性能优化的目标之一就是缩短导航完成所花费的时间 在理想情况下 它通常不会花费太多的时间 但是等待时间和带宽会导致它的延时

## DNS 查询

导航的第一步是区寻找页面资源的位置 如果导航到 https://example.com HTML 页面被定位到 93.184.216.34 的服务器
如果以前没有访问过这个网站 就需要进行 DNS 查询

浏览器向域名服务器发起 DNS 查询请求 最终得到一个 IP 地址 第一次请求之后 这个 IP 地址可能会被缓存一段时间
这样可以通过从缓存里面检索 IP 地址而不是再通过域名服务器进行查询来加速后续的请求

通过主机名加载一个页面通常仅需要一次 DNS 查询 但是 对于页面指向不同的主机名 则需要多次 DNS 查询
如果字体、图像、脚本、广告和网站统计都有不同的主机名 则需要对每一个主机名进行 DNS 查询

DNS 查询可能存在性能问题 特别是对于移动网络 当一个用户使用了移动网络 每一个 DNS 查询必须从手机发送到基站 然后到达一个认证的 DNS 服务器
手机、信号塔、域名服务器之间的距离可能是一个大的时间等待

## TCP 握手

一旦获取到服务器 IP 地址 浏览器就会通过 TCP 三次握手与服务器建立链接 这个机制是用来让两端尝试进行通信
在浏览器和服务器通过上层协议 HTTPS 发送数据之前 可以协商网络 TCP 套接字链接的一些参数
终端与每台服务器之间还要来回发送三条消息 而请求尚未发出

## TLS 协商

为了在 HTTPS 上建立连接 另一种握手是必须的 更确切的说是 TLS 协商 它决定了什么密码将会被用来二次加密 验证服务器 在进行真实的数据传输之前建立安全连接
在发送真正的请求内容之前还需要三次往返服务器

虽然建立安全连接对增加了加载页面的等待时间 对于建立一个安全的连接来说 以增加等待时间为代价是值得的 因为在 web 服务器之间传输的数据不可以被第三方解密

## 响应

一旦建立了到 web 服务器的连接 浏览器就代表用户发送一个初始的 HTTP GET 请求 对于网站来说 这个请求通常是一个 HTML 文件 一旦服务器收到请求、它将使用
相关的响应头和 HTML 的内容进行回复

初始请求的响应包含所接收数据的第一个字节 `Time to First Byte`（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间 第一个内容分块通常是 14KB 的数据

### TCP 慢启动/14KB 规则

第一个响应数据包是 14KB 大小的 这是慢启动的一部分 慢启动是一种均衡网络连接速度的算法 慢启动逐渐增加发送数据的数量直到达到网络的最大带宽

在 TCP 慢启动中 在收到一个初始包后 服务器会将下一个数据包的大小加倍到大约 28KB 后续的数据包一次是前一个包大小的二倍 直到达到预定的阈值 或者遇到拥塞

TCP 慢启动就是初始响应为 14KB 的原因 也是为什么 web 性能优化需要将此初始 14KB 响应作为优化重点的原因

TCP 慢启动逐渐建立适合网络能力的传输速度 以避免拥塞

### 拥塞控制

当服务器用 TCP 数据包来发送数据时 客户端通过返回确认帧来确认传输 由于硬件和网络条件 连接的容量是有限的
如果服务器太快地发送太多的包 它们可能会被丢弃 这意味着 将不会有确认帧的返回 服务器把它们当作确认帧丢失
拥塞控制算法使用这个发送包和确认帧流来确定发送速率

## 解析

一旦浏览器接收到数据的第一块 它就可以开始解析收到的信息 `解析`是浏览器将通过网络接收的数据转换为 `DOM` 和 `CSSOM` 在屏幕上绘制成页面

`DOM` 是浏览器标记的内部表示 `DOM` 也是被暴露的 可以通过 JavaScript 中的各种 API 进行 DOM 操作

即使请求页面的 HTML 大于初始的 14KB 数据包 浏览器也将开始解析并尝试根据其拥有的数据进行渲染
这就是为什么在前 14KB 中包含浏览器开始渲染页面所需的所有内容 或者至少包含页面模板（第一次渲染所需的 CSS 和 HTML）对于 web 性能优化来说是重要的
但是在渲染到屏幕上之前 HTML、CSS、Javascript 必须被解析完成

### 构建 DOM 树

1. 处理 HTML 标记并构造 DOM 树
   HTML 解析涉及到 tokenization 和树的构造
   HTML 标记包括开始和结束标记 以及属性名和值 如果文档格式良好 则解析它会简单而快速 解析器将标记化的输入解析到文档中 构建文档树
   DOM 树描述了文档的内容 `<html>` 元素是第一个标签也是文档树的根节点
   树反映了不同标记之间的关系和层次结构 嵌套在其他标记中的标记是子节点 DOM 节点的数量越多 构建 DOM 树所需的时间就越长

   当解析器发现非阻塞资源 例如一张图片 浏览器会请求这些资源并继续解析 当遇到一个 CSS 文件时 解析也可以继续进行
   但是对于 `<script>` 标签（特别是没有 async 或 defer 属性的）会阻塞渲染并停止 HTML 的解析
   尽管浏览器的预加载扫描器加速了这个过程 但过多的脚本仍然是一个重要的瓶颈

### 预加载扫描器

浏览器构建 DOM 树时 这个过程占用了主线程 当这种情况发生时 预加载扫描仪将解析可用的内容并请求高优先级资源 如 CSS、Javascript 和 Web 字体
多亏了预加载扫描器 我们不必等到解析器找到最外部资源的引用来请求它 它将在后台检索资源 以便在主 HTML 解析器到达请求的资源时 它们可能已经在运行或已经被下载
预加载扫描器提供的优化减少了阻塞

```html
<link rel="stylesheet" src="styles.css" />
<script src="myscript.js" async></script>
<img src="myimage.jpg" alt="image description" />
<script src="anotherscript.js" async></script>
```

当主线程在解析 HTML 和 CSS 时 预加载扫描器将找到脚本和图像 并开始下载它们
为了确保脚本不会阻塞进程 当 JavaScript 解析和执行顺序不重要时 可以添加 async 属性或 defer 属性

等待获取 CSS 不会阻塞 HTML 的解析或者下载 但是它确实会阻塞 JavaScript
因为 JavaScript 经常用于查询元素的 CSS 属性

### 构建 CSSOM

2. 处理 CSS 并构建 CSSOM
   CSS 对象模型和 DOM 是相似的 DOM 和 CSSOM 是两棵树 它们是独立的数据结构 浏览器将 CSS 规则转换为可以理解和使用的样式映射
   浏览器遍历 CSS 中的每个规则集 根据 CSS 选择器创建具有父、子和兄弟关系的节点树
   与 HTML 一样浏览器需要将接收到的 CSS 规则转换为可以使用的内容 因此它重复了 HTML 到对象的过程
   CSSOM 树包括来自用户代理样式表的样式 浏览器从适用于节点的最通用规则开始 并通过应用更具体的规则递归地优化计算的样式

### JavaScript 编译

当 CSS 被解析并创建 CSSOM 时 其他资源 包括 JavaScript 文件正在下载（借助预加载扫描器）
Javascript 被解释、编译、解析和执行 脚本被解析为抽象语法树
一些浏览器引擎使用抽象语法树并将其传递到解释器中 输出在主线程上执行的字节码

### 构建辅助功能树

浏览器还构建辅助设备用于分析和解释内容的辅助功能树 无障碍对象模型（AOM）类似于 DOM 的语义版本
当 DOM 更新时 浏览器会更新辅助功能树 辅助技术本身无法修改无障碍树
在构建 AOM 之前，屏幕阅读器（screen readers (en-US)）无法访问内容

## 渲染

渲染步骤包括样式、布局、绘制 在某些情况下还包括合成
在解析步骤中创建的 CSSOM 树和 DOM 树组合成一个 Render 树 然后用于计算每个可见元素的布局 然后将其绘制到屏幕上
在某些情况下 可以将内容提升到它们自己的层并进行合成 通过在 GPU 而不熟 CPU 上绘制屏幕的一部分来提高性能 从而释放主线程

### Style

3. 将 DOM 和 CSSOM 组合成一个 Render 树 计算样式树或渲染树从 DOM 树的根开始构建 遍历每个可见节点
   像 `<head>` 和它的子节点以及任何具有 display:none 样式的结点 例如 `script { display: none }` 这些标签将不会显示 不会出现在 Render 树上
   具有 visibility:hidden 的节点会出现在 Render 树上 因为它们会占用空间
   每个可见节点都应用了其 CSSOM 规则 Render 树保存所有具有内容和计算样式的可见节点
   将所有相关样式匹配到 DOM 树中的每个可见节点 并根据 CSS 级联确定每个节点的计算样式

### Layout

4. 在渲染树上运行布局以计算每个节点的几何体 布局是确定呈现树中所有节点的宽度、高度和位置 以及确定页面上每个对象的大小和位置的过程
   回流是对页面的任何部分或整个文档的任何后续大小和位置的确定 浏览器从渲染树的根开始遍历它

   第一次确定节点的大小和位置称为布局 随后对节点大小和位置重新计算称为回流

### 绘制

5. 将各个节点绘制到屏幕上 第一次出现的节点称为 first meaningful paint(en-US)
   在绘制或光栅化阶段 浏览器将在布局阶段计算的每个框转换为屏幕上的实际像素
   绘画包括将元素的每个可视部分绘制到屏幕上 包括文本、颜色、边框、阴影和替换的元素
   浏览器需要非常快速地完成这项工作
