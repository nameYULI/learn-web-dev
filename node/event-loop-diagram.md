# Node.js 事件循环完整图解

## 📍 执行起点定位图

```
┌──────────────────────────────────────────────────────────────┐
│                     🚀 代码执行入口                            │
│                                                              │
│  1️⃣ 同步代码执行（Script Main）                                │
│     ↓                                                        │
│  2️⃣ 注册异步任务到对应队列                                      │
│     • setTimeout/setInterval → Timer 队列                    │
│     • setImmediate → Check 队列                             │
│     • I/O 操作 → Poll 队列                                   │
│     • process.nextTick → nextTick 队列                      │
│     • Promise.then → 微任务队列                              │
│     ↓                                                        │
│  3️⃣ 同步代码执行完毕，进入事件循环                               │
└──────────────────────────────────────────────────────────────┘
```

## 🔄 事件循环完整流程图

```
   ┌───────────────────────────┐
┌─>│           timers          │<────── setTimeout
│  │  (执行定时器回调)          │        setInterval
│  └─────────────┬─────────────┘
│                │
│                ↓ 【清空微任务】
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │<────── I/O 错误回调
│  │  (执行延迟的I/O回调)       │
│  └─────────────┬─────────────┘
│                │
│                ↓ 【清空微任务】
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │<────── 内部使用
│  │     (仅内部使用)          │
│  └─────────────┬─────────────┘
│                │
│                ↓ 【清空微任务】
│  ┌─────────────┴─────────────┐
│  │           poll            │<────── I/O 事件
│  │   (获取新的I/O事件)        │        文件读写
│  │                           │        网络请求
│  │  ● 计算阻塞时间           │
│  │  ● 处理poll队列事件        │
│  └─────────────┬─────────────┘
│                │
│                ↓ 【清空微任务】
│  ┌─────────────┴─────────────┐
│  │           check           │<────── setImmediate
│  │  (执行setImmediate回调)   │
│  └─────────────┬─────────────┘
│                │
│                ↓ 【清空微任务】
│  ┌─────────────┴─────────────┐
│  │      close callbacks      │<────── socket.close
└──┤   (执行close事件回调)      │        等关闭事件
   └───────────────────────────┘
```

## ⚡ 微任务执行时机图

```
┌──────────────────────────────────────────────────────┐
│              每个阶段结束后的微任务处理                  │
├──────────────────────────────────────────────────────┤
│                                                      │
│  阶段结束 → 微任务处理顺序：                           │
│                                                      │
│  1. process.nextTick 队列（递归清空）                 │
│     ┌─────────────────────────┐                     │
│     │ nextTick1 → nextTick2 → │ 全部执行完           │
│     └─────────────────────────┘                     │
│                ↓                                     │
│  2. Promise 微任务队列                               │
│     ┌─────────────────────────┐                     │
│     │ Promise1 → Promise2 →   │ 全部执行完           │
│     └─────────────────────────┘                     │
│                ↓                                     │
│  3. 进入下一个事件循环阶段                             │
│                                                      │
└──────────────────────────────────────────────────────┘
```

## 📊 定时器执行时机对比

```
场景1：在脚本开始时注册
────────────────────────
setTimeout(() => {}, 0)  ──┐
setTimeout(() => {}, 0)  ──┼──> 同一个 timer 阶段执行
setTimeout(() => {}, 5)  ──┘

场景2：在 timer 回调中注册
────────────────────────
setTimeout(() => {
  console.log('timer1');
  setTimeout(() => {      ────> 下一轮循环的 timer 阶段
    console.log('timer2');
  }, 0);
}, 0);

场景3：setTimeout vs setImmediate
────────────────────────────────
        当前循环            下一轮循环
Timer ────────────────> Timer
  ↓                       ↑
Check (setImmediate)      │
  ↓                       │
  └───────────────────────┘
```

## 🎯 代码执行定位快速查询表

| 代码类型 | 执行时机 | 执行阶段 | 优先级 |
|---------|---------|---------|--------|
| 同步代码 | 立即执行 | Main Script | 最高 |
| process.nextTick | 当前阶段结束后 | 微任务 | 高 |
| Promise.then | nextTick 之后 | 微任务 | 中高 |
| setTimeout(0) | 下一个 timer 阶段 | Timer | 中 |
| setImmediate | 当前/下一个 check 阶段 | Check | 中低 |
| I/O 回调 | Poll 阶段 | Poll | 低 |

## 💡 关键理解点

1. **代码从哪开始？**
   - 永远从同步代码开始
   - 同步代码执行时注册各种异步任务

2. **如何判断执行顺序？**
   - 看注册时机：何时被加入队列
   - 看当前阶段：事件循环在哪个阶段
   - 看队列类型：微任务 > 宏任务

3. **为什么有时顺序不同？**
   - Timer 阶段的快照机制
   - 微任务的递归处理
   - I/O 的不确定性

## 🔍 调试技巧

```javascript
// 追踪当前执行位置
function trace(label) {
  console.log(`[${Date.now()}] ${label}`);
  console.trace(); // 显示调用栈
}

// 标记不同类型的异步操作
setTimeout(() => trace('TIMER'), 0);
setImmediate(() => trace('IMMEDIATE'));
process.nextTick(() => trace('NEXTTICK'));
Promise.resolve().then(() => trace('PROMISE'));
```