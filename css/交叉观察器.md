参考文档：[交叉观察器API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)


> 交叉观察器API提供了一种异步检测目标元素与祖先元素或顶级文档的视口相交情况变化的方法

使用场景：
1. 在页面滚动时 懒加载图像或其他内容

2. 实现“无限滚动”网站 在滚动过程中加载和显示越来越多的内容 这样用户就不必翻页

3. 报告广告的可见度 以便计算广告收入

4. 根据用户是否能看到结果来决定是否执行任务或动画进程

过去实施相交检测时 需要调用事件处理程序和循环办法 如 `Element.getBoundingClientRect()`来为每个受影响的元素建立所需的信息 由于所有这些代码都在主线程上运行 因此即使是其中的一行代码也会导致性能问题

交叉观察器API可令代码注册一个回调函数 当特定元素进入或退出与另一元素（或视口）的交集时 或者当两个元素之间的交集发生指定变化时 该函数就会被执行 这样网站就不需要在主线程上做任何事情来监视这种元素交集 浏览器也可以根据自己的需要优化交集管理

交叉观察器API无法提供重叠像素的确切数量或具体是哪些像素重叠 不过它涵盖了“如果它们相交N%左右 我需要做什么”这种更常见的用例

#### 概念和用法

交叉观察器API允许你配置一个回调函数 当以下情况发生时会被调用

1. 目标元素与设备视口或指定元素相交 在交叉观察器API中 指定元素被称为根元素或根

2. 观察器 observer 第一次监听观察目标元素

通常情况下 需要观察目标元素最近的可滚动祖先的交集变化 如果目标元素不是可滚动元素的后代 则需要观察设备视口的交集变化 要观察相对于设备视口的交集 请为root选项指定null

无论你是使用视口还是其他元素作为根元素 API的工作方式都是一样的 只要目标元素的可见性发生变化 与根元素的交集达到所需的程度 就会执行你提供的回调函数

目标元素与其根元素的交集程度就是交叉比 它表示目标元素可见的百分比 数值介于0.0和1.0之间

通过调用IntersectionObserver构造函数 创建交叉观察器 并将回调函数传给它 当一个方向或另一个方向越过阈值时 就运行该函数

```js
let options = {
  root: document.querySelector("#scrollArea"),
  rootMargin: "0px",
  threshold: 1.0,
};

let observer = new IntersectionObserver(callback, options);
```

阈值为1.0意味着目标元素完全出现在root选项指定的元素中100%可见时 回调函数将会被执行

传递给`IntersectionObserver()`构造函数的options对象 可以控制在什么情况下调用观察器的回调 它有以下字段

`root`：用作视口的元素 用于检查目标的可见性 必须是目标的祖先 如果未指定或为null 则默认为浏览器视口

`rootMargin`：根周围的边距 其值可以类似于css的margin属性 例如"10px 20px 30px 40px"（上 右 下 左）这些值可以是百分比 在计算交叉点之前 这组值用于增大或缩小根元素边框的每一侧 默认值全为0

`threshold`：一个数字或一个数字数组 表示目标元素可见度达到多少百分比时 观察器的回调就应该执行 如果只想在能见度超过50%时检测 可以使用0.5的值 如果希望每次能见度超过25%时都执行回调 则需要指定数组[0,0.25,0.5,0.75,1]  默认值为0（意味着只要有一个像素可见 回调就会运行） 值为1.0意味着在每个像素都可见之前 阈值不会被认定为已通过

##### 定位要观察的元素

```js
let target = document.querySelector("#listItem");
observer.observe(target);

// 我们为观察器设置的回调将在第一次执行，
// 它将等待我们为观察器分配目标（即使目标当前不可见）
```

回调函数：

```js
let callback = (entries, observer) => {
  entries.forEach((entry) => {
    // 每个条目描述一个目标元素观测点的交叉变化：
    //   entry.boundingClientRect
    //   entry.intersectionRatio
    //   entry.intersectionRect
    //   entry.isIntersecting
    //   entry.rootBounds
    //   entry.target
    //   entry.time
  });
};
```

回调接收到的条目列表包括每个报告了相交状态变化的目标的一个条目 检查`isIntersecting`属性的值 查看条目是否代表当前与根相交的元素

请留意 你注册的回调将回在主线程中被执行 所以该函数执行速度尽可能要快 如果需要执行任何耗时多的操作 请使用`Window.requestIdleCallback()`

此外请注意 如果指定了root选项 目标必须是根元素的后代

##### 交集的计算

交叉观察器API所考虑的所有区域都是矩形 形状不规则的元素被视为占据了包围元素所有部分的最小矩形 同样 如果元素的可见部分不是矩形 那么该元素的交点矩形将被视为包含该元素所有可见部分的最小矩形

##### 交集根与根边距

在跟踪元素与容器的交集之前 我们需要知道容器是什么 这个容器就是交集根或根元素 它可以是文档中作为要观察元素的祖先的特定元素 也可以是null 即使用文档的视口作为容器

*根交集矩形*是用于检查目标或多个目标的矩形 这个矩形是这样确定的

1. 如果交集根是隐式根（即顶级Document）根交叉点矩形就是视口的矩形

2. 如果交集根存在溢出剪切 根交集矩形就是根元素的内容区域

3. 否则 根交集矩形就是交集根的客户端边界矩形（通过调用`getBoundingClientRect()`返回）

